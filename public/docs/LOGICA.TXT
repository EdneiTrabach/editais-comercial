// Remoções no ProcessosView.js:

// 1. Remover do array de colunas a entrada de sistemas_ativos:
const colunas = [
  { titulo: 'Data', campo: 'data_pregao' },
  { titulo: 'Hora', campo: 'hora_pregao' },
  { titulo: 'Modalidade', campo: 'modalidade' },
  { titulo: 'Estado', campo: 'estado' },
  { titulo: 'Nº Processo', campo: 'numero_processo' },
  { titulo: 'Objeto Resumido', campo: 'objeto_resumido' },
  // Coluna de sistemas removida
  { titulo: 'Código Análise', campo: 'codigo_analise' },
  { titulo: 'Órgão', campo: 'orgao' },
  { titulo: 'Objeto Completo', campo: 'objeto_completo' },
  { titulo: 'Status', campo: 'status' },
  // outras colunas...
];

// 2. Remover const sistemasNomesCache e sistemasAtivos do setup()
// 3. Remover funções: getSistemasNomes, getSistemaNome, getSistemasNomesString, loadSistemas
// 4. Remover sistemasDialog do setup()
// 5. Remover funções de manipulação de sistemas:
//    - handleSistemasChange
//    - removerSistema
//    - saveSistemas
//    - hideSistemasDialog

// 6. Remover case 'sistemas_ativos' do switch em handleUpdate
// 7. Remover condição especial para sistemas_ativos no handleDblClick

// 8. Na onMounted, remover a chamada a loadSistemas()
// 9. Remover sistemasDialog e funções relacionadas do return



<!-- Remoções no ProcessosView.vue: -->

<!-- 1. Remover coluna de sistemas no template v-for dos headers -->
<!-- 2. Nos tds, remover condição especial para coluna.campo === 'sistemas_ativos' -->
<!-- 3. Remover todo o bloco dialog para sistemas:
    <div v-if="sistemasDialog.show" class="sistemas-dialog" ...> --></div>



    /* Remoções no ProcessosView.css: */

/* Remover todos estes estilos:
.sistemas-dropdown-container
.sistemas-selected
.sistema-chip
.sistema-remove
.sistemas-select
.sistemas-dialog
.sistemas-dialog-content
.sistemas-dialog h3
.sistemas-lista
etc.
*/



Explicação sobre as Operações de Banco de Dados
Como funciona a conexão com o banco de dados
O sistema utiliza o Supabase como backend, que é um serviço que fornece uma API PostgreSQL acessível via JavaScript. A instância do Supabase é configurada em @/lib/supabase.js:


import { createClient } from '@supabase/supabase-js'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseKey = import.meta.env.VITE_SUPABASE_KEY

export const supabase = createClient(supabaseUrl, supabaseKey)



Como são feitas as consultas SELECT
O padrão usado no código para buscar dados é:

const loadProcessos = async () => {
  try {
    // Iniciar loading
    isLoading.value = true
    
    // Fazer a consulta com Supabase
    const { data, error } = await supabase
      .from('processos')  // Nome da tabela
      .select(`*`)        // Colunas a selecionar (* = todas)
      .order('data_pregao', { ascending: true })  // Ordenação
    
    // Tratar possíveis erros
    if (error) throw error
    
    // Processar os dados retornados
    processos.value = data || []
    
  } catch (error) {
    console.error('Error loading processes:', error)
  } finally {
    // Finalizar loading independentemente do resultado
    isLoading.value = false
  }
}



const loadProcessos = async () => {
  try {
    // Iniciar loading
    isLoading.value = true
    
    // Fazer a consulta com Supabase
    const { data, error } = await supabase
      .from('processos')  // Nome da tabela
      .select(`*`)        // Colunas a selecionar (* = todas)
      .order('data_pregao', { ascending: true })  // Ordenação
    
    // Tratar possíveis erros
    if (error) throw error
    
    // Processar os dados retornados
    processos.value = data || []
    
  } catch (error) {
    console.error('Error loading processes:', error)
  } finally {
    // Finalizar loading independentemente do resultado
    isLoading.value = false
  }
}


Para consultas mais complexas, o Supabase permite:

Filtrar com .eq(), .neq(), .gt(), .lt(), etc.
Limitar resultados com .limit()
Paginação com .range()
Junções/relacionamentos com um formato específico no select()
Por exemplo, para carregar representantes:


const { data, error } = await supabase
  .from('representantes')
  .select('*')           // Seleciona todas as colunas
  .order('nome')         // Ordena por nome


  Como são feitas as operações UPDATE
Para atualizar registros:


const handleUpdate = async (processo) => {
  try {
    // Preparar dados para atualização
    const updateData = {
      [editingCell.value.field]: editingCell.value.value,
      updated_at: new Date().toISOString()
    }
    
    // Adicionar informação do usuário que está fazendo a alteração
    const { data: { user } } = await supabase.auth.getUser()
    if (user?.id) {
      updateData.updated_by = user.id
    }
    
    // Fazer o update no banco de dados
    const { error } = await supabase
      .from('processos')
      .update(updateData)
      .eq('id', processo.id)
    
    if (error) throw error
    
    // Recarregar os dados após o update
    await loadProcessos()
    
  } catch (error) {
    console.error('Error updating:', error)
    alert(`Error updating field: ${error.message || 'Check the data and try again'}`)
  }
}




Como são feitas as operações INSERT (POST)
Embora não seja mostrado no código compartilhado, o padrão para inserir registros seria:


const createProcess = async (processData) => {
  try {
    const { data, error } = await supabase
      .from('processos')
      .insert(processData)
      .select()  // Opcional: retorna o registro inserido
    
    if (error) throw error
    return data
  } catch (error) {
    console.error('Error creating process:', error)
    throw error
  }
}

Como são feitas as operações DELETE
Para excluir registros:

const confirmDelete = async () => {
  try {
    const processo = deleteConfirmDialog.value.processo
    
    // Registrar a ação de exclusão (opcional)
    await logSystemAction({
      tipo: 'exclusao',
      tabela: 'processos',
      registro_id: processo.id,
      dados_anteriores: processo
    })
    
    // Executar a exclusão
    const { error } = await supabase
      .from('processos')
      .delete()
      .eq('id', processo.id)
    
    if (error) throw error
    
    // Atualizar a interface após exclusão
    processos.value = processos.value.filter(p => p.id !== processo.id)
    
    hideDeleteDialog()
  } catch (error) {
    console.error('Error deleting:', error)
    alert('Error deleting process')
  }
}



const confirmDelete = async () => {
  try {
    const processo = deleteConfirmDialog.value.processo
    
    // Registrar a ação de exclusão (opcional)
    await logSystemAction({
      tipo: 'exclusao',
      tabela: 'processos',
      registro_id: processo.id,
      dados_anteriores: processo
    })
    
    // Executar a exclusão
    const { error } = await supabase
      .from('processos')
      .delete()
      .eq('id', processo.id)
    
    if (error) throw error
    
    // Atualizar a interface após exclusão
    processos.value = processos.value.filter(p => p.id !== processo.id)
    
    hideDeleteDialog()
  } catch (error) {
    console.error('Error deleting:', error)
    alert('Error deleting process')
  }
}


Resumo das Operações
SELECT: .from(tabela).select(colunas).filtros()
INSERT: .from(tabela).insert(dados)
UPDATE: .from(tabela).update(dados).eq('id', id)
DELETE: .from(tabela).delete().eq('id', id)
Cada operação retorna um objeto com data (dados retornados) e error (erro, se ocorrer).



